#!/bin/bash

import errcho

# latest modified file in dir tree under pwd or $1
path.last_modified () {
    find -L "${1:-.}" -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -f2- -d" "
}

path.rootdir () {
    local markerfile; markerfile="$1"
    local depth; depth=${2:-0}

    # If the supplied markerfile is the actual path to the file, we simply use its dir
    if [[ -f $markerfile ]]; then
        readlink --canonicalize-existing "$(dirname "$markerfile")"
        return 0
    fi

    # user supplied a relative or absolute path that includes at least one dir
    # component, but the file does not exist there
    if [[ $(dirname "$markerfile") != '.' ]]; then
        errcho "ERROR: markerfile '$markerfile' was expected to exist but it doesn't"
        return 1
    fi

    # search for the markerfile starting from where we are

    local scriptfile
    if [[ $0 == '-bash' ]]; then
        # called directly from commandline
        # yerrcho "Called from CLI"
        scriptfile=./DUMMY
    else
        # yerrcho "Called from script"
        # shellcheck disable=SC2046,2086
        set $(caller $depth)
        scriptfile=$3
    fi

    #yerrcho "Searching for $markerfile above $scriptfile using depth $depth"

    local dir; dir="$(dirname "$(readlink --canonicalize "$scriptfile")")"

    local startdir; startdir="$dir"

    while [[ $dir != / ]] ; do
        [[ -f $dir/$markerfile ]] && break
        dir=$(dirname "$dir")
    done

    if [[ $dir == / ]]; then
        errcho "No rootdir/$markerfile found above $startdir"
        return 1
    fi

    readlink --canonicalize-existing "$dir"
}

# when searching for rootdir from another stdlib function, need to go back one
# more frame in the callstack for the calling stdlib function, plus one more
# for this function
path.their.rootdir () {
    path._rootdir "$1" 2
}

pathtools.dir_is_empty () {
    [[ -n $(find "$1" -maxdepth 0 -type d -empty 2> /dev/null) ]]
}

path.backup () {
    local path; path="$1"

    if [[ -f "$path" ]]; then
        local ts; ts=$(date +"%Y-%m-%d_%H-%M-%S")
        mv "$path" "$path.$ts"
    fi
}

# mkdir -p is too loose, mkdir EXISTING_DIR is an error
path.mkdir.ifmissing () {
    local dir; dir="$1"
    [[ -d $dir ]] && return 0
    mkdir "$dir"
}
