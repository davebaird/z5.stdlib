#!/bin/bash
import errcho
import pidtools
import checks
import installer

install.apt.pkgs software-properties-common curl

dtools.ip () {
    local dname; dname="$1"
    dtools.waitfor "$dname"
    local ip; ip=$(docker inspect --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "$dname")
    echo "$ip"
    return 0
}

dtools.stop () {
    local dname; dname="$1"

    if dtools.container.running "$dname"
    then
        docker stop "$dname"
    fi

    if dtools.container.exists  "$dname"
    then
        docker rm --force "$dname"
    fi

}

dtools.container.running () {
    docker top "$1" > /dev/null 2>&1 && return 0
    return 1
}

dtools.container.exists () {
    docker container inspect "$1" > /dev/null 2>&1 && return 0
    return 1
}

# Wait for the container to be up, running, and functional, by checking it can
# generate log output. Then cleanup the log process.
dtools.waitfor () {
    local dname; dname="$1"
    local pid; pid=$(dtools.tail.log "$dname" /dev/null)
    stop.pid "$pid"
}

# How to launch a process in background and wait for it to start before moving on
# https://stackoverflow.com/a/33564955/2334574
dtools.tail.log () {
    local dname="$1"
    local logfile="$2"
    local pid
    local count

    while true; do
        docker logs -f "$dname" > "$logfile" 2>&1 &
        pid=$!

        # shellcheck disable=2009
        count=$(ps -A | grep --count $pid)   # check whether process is still running

        # if process is already terminated, then there can be two cases:
        #   the process executed and stopped successfully, or it terminated abnormally
        if [[ $count -eq 0 ]]; then
            if wait $pid    # checks if process executed successfully or not
            then
                errcho "docker logs $dname ran and exited - that's unexpected"
                return 1
            else            # process terminated abnormally
                debug "docker $dname not ready - can't start logging yet (returned $?)"
                sleep 0.1
            fi
        else                # process is still running
            errcho "docker logs $dname is running"
            break
        fi
    done

    echo "$pid"
    return 0
}

# https://docs.docker.com/engine/install/debian/
# https://docs.docker.com/engine/install/ubuntu/
dtools.docker.install () {
    local os; os=$(get.os)

    apt-get remove docker docker-engine docker.io containerd runc || :

    install.apt.pkgs gnupg2

    curl -fsSL "https://download.docker.com/linux/$os/gpg" | apt-key add -

    add-apt-repository --yes \
        "deb [arch=amd64] https://download.docker.com/linux/$os $(lsb_release -cs) stable"

    install.apt.pkgs apt-transport-https ca-certificates curl gnupg-agent \
                        software-properties-common docker-ce docker-ce-cli containerd.io

    groupadd docker > /dev/null 2>&1 || :

    systemctl enable docker > /dev/null 2>&1
}

# don't use the shortcut, the script returns 1 if not root, but somehow doesn't
# trigger en exit under set -e, unless stacktrace is loaded, and other hidden
# weird shit as well
if test.i_can_root
then
    dtools.docker.install
fi

