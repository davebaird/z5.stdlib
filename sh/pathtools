#!/bin/bash

import errcho

# latest modified file in dir tree under pwd or $1
path.last_modified () {
    find -L "${1:-.}" -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -f2- -d" "
}

path.rootdir () {
    local markerfile; markerfile="$1"
    local depth; depth=${2:-0}

    # If the supplied markerfile is the actual path to the file, we simply use its dir
    if [[ -f $markerfile ]]; then
        readlink --canonicalize-existing "$(dirname "$markerfile")"
        return 0
    fi

    # user supplied a relative or absolute path that includes at least one dir
    # component, but the file does not exist there
    if [[ $(dirname "$markerfile") != '.' ]]; then
        errcho "ERROR: markerfile '$markerfile' was expected to exist but it doesn't"
        return 1
    fi

    # search for the markerfile starting from where we are

    local scriptfile
    if [[ $0 == '-bash' ]]; then
        # called directly from commandline
        scriptfile=./DUMMY
    else
        local IFS=' ' # this remains set for the remainder of this function, but I think that's ok
        # shellcheck disable=SC2046,2086
        set $(caller $depth)
        scriptfile=$3
    fi

    local dir; dir="$(dirname "$(readlink --canonicalize "$scriptfile")")"

    _search_upwards_for_rootdir "$dir" "$markerfile"
}

path.rootdir.pwd () {
    local markerfile; markerfile="$1" # e.g. .poet_root
    local dir; dir="$PWD"
    _search_upwards_for_rootdir "$dir" "$markerfile"
}

_search_upwards_for_rootdir () {
    local dir markerfile; dir="$1"; markerfile="$2"

    local startdir; startdir="$dir"

    while [[ $dir != / ]] ; do
        [[ -f $dir/$markerfile ]] && break
        dir=$(dirname "$dir")
    done

    if [[ $dir == / ]]; then
        errcho "No rootdir/$markerfile found above $startdir"
        return 1
    fi

    readlink --canonicalize-existing "$dir"
}

# when searching for rootdir from another stdlib function, need to go back one
# more frame in the callstack for the calling stdlib function, plus one more
# for this function
path.their.rootdir () {
    path._rootdir "$1" 2
}

path.is.empty.dir () {(
    set +e
    [[ -n $(find "$1" -maxdepth 0 -type d -empty 2> /dev/null) ]]
)}

path.is.not.empty.dir () {(
    set +e
    ! path.is.empty.dir "$1"
)}

# # Not just sugar. In cleanup.add, can't pass in things like '&&'
# ## or just say rmdir --ignore-fail-on-non-empty
# path.rmdir.if.empty () {
#     local dir; dir="$1"
#     path.is.empty.dir "$dir" && rmdir --verbose "$dir"
# }


path.backup () {
    local path; path="$1"

    if [[ -f "$path" ]]; then
        local ts; ts=$(date +"%Y-%m-%d_%H-%M-%S")
        mv "$path" "$path.$ts"
    fi
}

# mkdir -p is too loose, mkdir EXISTING_DIR is an error
path.mkdir.if.missing () {
    local dir; dir="$1"
    [[ -d $dir ]] && return 0
    mkdir "$dir"
}

path.is.absolute () {(
    set +e
    [[ $1 =~ ^/ ]]
)}

path.is.relative () {(
    set +e
    ! path.is.absolute "$@"
)}

:
