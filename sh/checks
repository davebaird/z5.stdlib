#!/bin/bash
import errcho

# checks errexit
# tests return 0/1 return code
# gets echo a piece of information

check.i_am_root () {
    check.i_can_root
    check.homedir root
    check.i_can_sbin
}

check.i_can_sbin () {
    which groupadd > /dev/null || errxit "root environment not properly initialised - sbin not in PATH"
}

# shellcheck disable=SC2120
check.i_can_root () {
    local msg; msg=${1:-$0 must be run as root}
    test.i_can_root || errxit "$msg"
}

test.i_can_root () {(
    set +e
    [[ $EUID -eq 0 ]]
)}

check.is_getopt_enhanced () {
    # The leading exclamation does this:
    #   - allow a command to fail with !'s side effect on errexit
    #   - use return value from ${PIPESTATUS[0]}, because ! hosed $?
    ! getopt --test > /dev/null
    [[ ${PIPESTATUS[0]} -eq 4 ]] && return 0
    errxit 'getopt (enhanced) not available in this environment'
}

# server info
# cat /etc/os-release
# cat /etc/lsb-release
# uname -a
test.is_debian () {
    [[ $(get.os) == debian ]]
}

test.is_ubuntu () {
    [[ $(get.os) == ubuntu ]]
}

get.os () {
    source /etc/os-release
    echo "$ID"
}

# how sudo and su set up things is subtle and can vary from one host to another
check.homedir () {
    local user; user="${1}"

    homedir="$(eval echo "~$user")"

    if [[ "$HOME" != "$homedir" ]]; then
        errxit "\$HOME [$HOME] does not agree with \$(eval echo "~\$user") [$homedir] for user $user"
    fi

    if [[ $user == root ]]; then
        [[ $HOME == /root ]]       || errxit "Wrong home for root: $HOME"
    else
        [[ $HOME == /home/$user ]] || errxit "Wrong home for $user: $HOME"
    fi
}