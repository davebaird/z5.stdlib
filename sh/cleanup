#!/bin/bash
import errcho

# Modified from script found here: https://blog.dhampir.no/content/fixing-shmget-failed-no-space-left-on-device
cleanup.shared_memory () {
    # shellcheck disable=SC2162
    while read key id owner nattch; do
        if [[ -z $key ]] || [[ -z $id ]] || [[ -z $owner ]]; then
            errcho "Ignoring invalid line from ipcs: [${key} ${id} ${owner} ${nattch}]"
            continue
        fi

        local output
        if output=$(ipcrm shm "$id" 2>&1); then
            gerrcho "Cleanup shared memory: removed [${key} ${id} ${owner} ${nattch}]"
        else
            errcho "Failed to delete line from ipcs: [${key} ${id} ${owner} ${nattch}]"
            errcho "Output given: [${output}]"
        fi
    done < <(ipcs -m | grep "^0x" | awk '{print $1, $2, $3, $6}' | grep " 0$" | grep "$USER")
}

# https://riptutorial.com/bash/example/2398/accumulate-a-list-of-trap-work-to-run-at-exit-
# Usage:
#   cleanup.add rm -f /tmp/foo
#   cleanup.add echo "I am exiting"
#   tempfile=$(mktemp)
#   cleanup.add rm -f "$tempfile"
# Based on http://www.linuxjournal.com/content/use-bash-trap-statement-cleanup-temporary-files

# the -g, and empty array assignment, are required
declare -ag __cleanup_on_exit_items; __cleanup_on_exit_items=()

function cleanup._on_exit () {
    local errcode; errcode=$?
    nostrict
    berrcho "===== Running cleanup for $0 ====="

    for i in "${__cleanup_on_exit_items[@]}"
    do
        eval "$i"
    done

    exit "$errcode"
}

function cleanup.add () {
    local -i n; n="${#__cleanup_on_exit_items[@]}"
    local IFS=$' \n\t'
    # gerrcho "Adding cleanup: " "$@"
    __cleanup_on_exit_items[$n]="$*"
    [[ $n -eq 0 ]] && trap cleanup._on_exit EXIT
    :
}

:
